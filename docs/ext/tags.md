Tags [RU]
=========

В шаблонизаторе принято различать два типа тегов: компиляторы и функции.
Компиляторы вызываются во время преобразования кода шаблона в PHP код и возвращяю PHP код который будет вставлен вместо тега.
А функции вызываются непременно в момент выполнения шаблона и возвращают непосредственно данные которые будут отображены.
Среди тегов как и в HTML есть строчные и блоковые теги.

## Inline function

Примитивное добавление функции можно осуществить следующим образом:

```php
$cytro->addFunction(string $function_name, callable $callback[, callable $parser]);
```

В данном случае запускается стандартный парсер, который автоматически разберет аргументы тега, которые должны быть в формате HTML аттрибутов и отдаст их в функцию ассоциативным массивом.
В данном случае вы можете переопределить парсер на произвольный в формате `function (Cytro\Tokenizer $tokenizer, Cytro\Template $template)`
Существует более совершенный способ добавления функции:

```php
$cytro->addFunctionSmarty(string $function_name, callable $callback);
```

В данном случае парсер просканирует список аргументов коллбека и попробует сопоставить с аргументами из тега. Таким образом вы успешно можете добавлять Ваши штатные функции.

## Block function

Добавление блоковой функции аналогичен добавлению строковой за исключением того что есть возможность указать парсер для закрывающего тега.

```php
$cytro->addBlockFunction(string $function_name, callable $callback[, callable $parser_open[, callable $parser_close]]);
```

Сам коллбек принимает первым аргументом контент между открывающим и закрывающим тегом, а вторым аргументом - ассоциативный массив из аргуметов тега.

## Inline compiler

Добавление строчного компилятора осуществляеться очень просто:

```php
$cytro->addCompiler(string $compiler, callable $parser);
```

Парсер должен принимать `Cytro\Tokenizer $tokenizer`, `Cytro\Template $template` и возвращать PHP код.
Компилятор так же можно импортировать из класса автоматически

```php
$cytro->addCompilerSmart(string $compiler, $storage);
```

`$storage` может быть как классом так и объектом. В данном случае шаблонизатор будет искать метод `tag{$compiler}`, который будет взят в качестве парсера тега.

## Block compiler

Добавление блочного компилятора осуществяется двум способами. Первый

```php
$cytro->addBlockCompiler(string $compiler, array $parsers, array $tags);
```

где `$parser` ассоциативный массив `["open" => parser, "close" => parser]`, сождержащий парсер на открывающий и на закрывающий тег, а `$tags` содержит список внутренних тегов в формате `["tag_name"] => parser`, которые могут быть использованы только с этим компилятором.
Второй способ добавления парсера через импортирование из класса или объекта методов:

```php
$cytro->addBlockCompilerSmart(string $compiler, $storage, array $tags, array $floats);
```

